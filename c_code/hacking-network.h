
#define ETHER_ADDR_LEN 6
#define ETHER_HDR_LEN 14

struct ether_hdr {
	unsigned char ether_dst_addr[ETHER_ADDR_LEN]; // Destination MAC address
	unsigned char ether_src_addr[ETHER_ADDR_LEN]; // source MAC address
	unsigned short ether_type; 		// Type of ethernet packet
};

struct ip_hdr {
	unsigned char ip_version_and_header_length; // Version and header length
	unsigned char ip_tos;	// type of service
	unsigned short ip_len;  // total length
	unsigned short ip_id;   // identification number
	unsigned short ip_frag_offset; // IP Fragment offset and flags
	unsigned char ip_ttl;	// time to live
	unsigned char ip_type; // Protocol Type
	unsigned short ip_checksum; // Checksum
	unsigned int ip_src_addr; // Source IP address
	unsigned int ip_dst_addr; // Destination IP addres
};

struct tcp_hdr {
	unsigned short tcp_src_port; // Source TCP Port
	unsigned short tcp_dest_port; // Destination TCP Port
	unsigned int tcp_seq; // TCP Sequence Number
 	unsigned int tcp_ack; // TCP Acknowledgement number 
	unsigned char reserved:4; // four bits from the 6 bits of reserved space
	unsigned char tcp_offset:4; // TCP Data offset for little endian host 
	unsigned char tcp_flags; // TCP Flags, 2 bits from reserved space 
#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PUSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20
	unsigned short tcp_window; // TCP Wndow Size
	unsigned short tcp_checksum; // TCP Checksum
	unsigned short tcp_urgent; // TCP Urgent pointer 
};

/* This function accepts a socket FD and a ptr to a null terminated string 
 * string to send. This function will make sure all bytes are sent. 1 on success 0 on fa * failure */

int send_string(int sockfd, unsigned char* buffer) {
	int sent_bytes, bytes_to_send;
	bytes_to_send = strlen(buffer);
	while (bytes_to_send > 0) {
		sent_bytes = send(sockfd, buffer, bytes_to_send, 0);
		if (sent_bytes == -1) 
			return 0; // returns zero on error 
		bytes_to_send -= sent_bytes;
		buffer += sent_bytes;		
	}
	return 1; // return 1 on success 
}

/* This function accepts some socket FD and a ptr to a destination buffer 
 * It will recieve from the socket until the EOL byte sequence is seen. 
 * The EOL is read from the the socket but the buffer is null terminated befor
 * these bytes.
 * Returns the size of the read bytes (without EOL bytes) */
int recv_line(int sockfd, unsigned char* dest_buffer) {
#define EOL "\r\n" // end of line byte sequence 
#define EOL_SIZE 2 
	unsigned char * ptr;
	int eol_matched = 0;
	
	ptr = dest_buffer;
	while (recv(sockfd, ptr, 1, 0) == 1) { // read a single byte 
		if (*ptr == EOL[eol_matched]) {
			eol_matched++;
			if (eol_matched == EOL_SIZE) { // all bytes match the termination sequence
				*(ptr+1-EOL_SIZE) = '\0'; // terminate the string
				return strlen(dest_buffer); // return the number of bytes received
			}
		} else {	
			eol_matched = 0;
		}
		ptr++; // increment ptr to the next byte 
	} 
	return 0; // we didn't find EOL characters 
}

